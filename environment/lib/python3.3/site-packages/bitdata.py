#! environment/bin/python3.3
#This module contains classes and functions used for controlling binary data.

from math import floor
from numpy import bool_
import ipdb

class BitBlock(list):
    """Filters and stores the bits in a list""" 
    def __init__(self, bitstring="", purify=True):
        if purify == True:
            self.purify_bits(bitstring)
        else:
            list.__init__(self, bitstring)
    def purify_bits(self, bitstring):
        purebits = map(int, bitfilter(bitstring))
        self.__init__(purebits, False)
    def uniform(self, bit):
        return len([x for x in self if x == bit])
    def count_differences(self):
        return abs(self.uniform(0) - self.uniform(1))
    def bit_ratio(self,bit):
        return self.uniform(bit) / len(self)
    def append(self, arg):
        """Provides same functionality as list.append, although
        it converts the argument to a BitBlock"""
        bitstring = ''.join(str(arg))
        newblock = BitBlock(bitstring)
        list.append(self, newblock)
    def transform_bit(self, oldbit, newvalue):
        map_function = bit_transformer(oldbit, newvalue)
        return BitBlock(map(map_function, self), False)

def bitmatrix(bits, rows, cols):
    return [ [bit for bit in bits[i*cols:(i+1)*cols]] for i in range(rows)] 

def is_bit(bit):
    try:
        return (int(bit) == 0 or int(bit) == 1)
    except(ValueError, TypeError):
        return False

def bitfilter(bitstring):
    return filter(is_bit, bitstring)

def bit_transformer(oldbit, newvalue):
    def bit_swap(bit):
        if bit == oldbit:
            return newvalue
        else:
            return bit
    return bit_swap

def swap_bit(bit):
    """Converts 0 to 1 and vice versa. Returns the argument if it is not a bit"""
    if is_bit(bit):
        return abs((bit - 1))
    else:
        return bit

def balancebits(bit):
    """Used for ensuring that bits are equally distributed around 0."""
    if bit == 0:
        return -1
    else:
        return bit
  
def partition_bits(bits, blocksize):
    """When given either a bit block or a string containing bits
    and a blocksize, this function will return an array of bitblocks
    of length blocksize. It will automatically discard everything the 
    bits that are not long enough to create a full bitblock of size 
    'blocksize'"""
    bitblock = BitBlock(bits)
    blockcount = floor(len(bitblock)/blocksize)
    bitblocks = BitBlock("")
    for i in range(blockcount):
        bitblocks.append(bitblock[i*blocksize : (i+1)*blocksize])
    return bitblocks
